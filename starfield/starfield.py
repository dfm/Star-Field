"""


"""

__all__ = ["PSF", "StarField"]


import numpy as np

class PSF(object):
    """
    A mixture-of-Gaussians approximation of a pixel-convolved point-spread
    function.

    ## Arguments

    * `amplitudes` (list or float): The relative amplitudes of the
      components.
    * `variances` (list or float): The list of variances for the components.

    """
    def __init__(self, amplitudes, variances):
        self.variances = np.atleast_1d(variances)
        self.amplitudes = np.atleast_1d(amplitudes)
        self.amplitudes /= np.sum(self.amplitudes)

    def image(self, x, y, flux=1., nx=200, ny=200, img=None, wfactor=5):
        """
        Get the image generated by a point source at a given position.

        ## Arguments

        * `x` (float): The x-position of the source.
        * `y` (float): The y-position of the source.

        ## Keyword Arguments

        * `flux` (float): The flux of the source.
        * `nx` (int): The width of the image.
        * `ny` (int): The height of the image.
        * `img` (numpy.ndarray): A preallocated image object to add to. If
          this is not `None` it will override the value of `nx` and `ny`.
        * `wfactor` (float): The factor to multiply the maximum width by to
          set the maximum distance threshold.

        ## Returns

        * `img` (numpy.ndarray): The image where the shape is given by
          `(nx, ny)`.

        """
        # Find the dimensions of the image if it's provided and generate an
        # "image" of zeros if not.
        if img is not None:
            nx, ny = img.shape
        else:
            img = np.zeros((nx, ny))

        # Generate a pixel grid.
        x0, y0 = np.arange(nx), np.arange(ny)

        # Then, calculate the distances (on this grid) from the central point.
        r2 = - ((x - x0)**2)[:, None] - ((y - y0)**2)[None, :]

        # For speed, just consider the points where the distance is less than
        # some factor times the maximum width.
        mask = r2 > -wfactor * np.max(self.variances)

        # Calculate the full image as a mixture of Gaussians on the pixel
        # grid.
        t =  np.exp(r2[mask][:,None] / self.variances[None, :])
        t /= np.sum(t, axis=0)
        img[mask] += flux * np.sum(self.amplitudes[None, :] * t, axis=-1)

        return img

class StarField(object):
    """
    A field of stars with known PSF, dimensions and a given set of _pixel_
    positions and fluxes.

    ## Arguments

    * `psf` (PSF): The pixel-convolved point-spread function.
    * `nx` (int): The width of the image.
    * `ny` (int): The height of the image.

    """
    def __init__(self, psf, nx, ny):
        self.psf  = psf
        self.nx   = nx
        self.ny   = ny
        self.x    = np.array([])
        self.y    = np.array([])
        self.flux = np.array([])

    def _gen_fluxes(self, N, p, f0):
        return f0*10.**(np.random.rand(N)/p)

    def generate_bg_stars(self, N, p=-2, f0=100.):
        """
        Generate a set of uniformly distributed stars drawn from a given
        luminosity function.

        ## Arguments

        * `N` (int): The number of background stars.

        ## Keyword Arguments

        * `p` (float): The log-slope of the luminosity function.
        * `f0` (float): The normalization of the luminosity function.

        """
        flux = self._gen_fluxes(N, p, f0)
        x, y = self.nx * np.random.rand(N), self.ny * np.random.rand(N)

        self.flux = np.append(self.flux, flux)
        self.x    = np.append(self.x, x)
        self.y    = np.append(self.y, y)

    def generate_gaussian_stars(self, N, x0, y0, cov, p=-2, f0=100.):
        """
        Generate a set of stars drawn from a 2D Gaussian with given mean and
        covariance.

        ## Arguments

        * `N` (int): The number of stars.
        * `x0`, `y0` (float, float): The central position of the cluster.
        * `cov` (numpy.ndarray): The covariance matrix giving the cluster
          shape.

        ## Keyword Arguments

        * `p` (float): The log-slope of the luminosity function.
        * `f0` (float): The normalization of the luminosity function.

        """
        flux = self._gen_fluxes(N, p, f0)
        xy = np.random.multivariate_normal([x0, y0], cov, N)

        self.flux = np.append(self.flux, flux)
        self.x    = np.append(self.x, xy[:,0])
        self.y    = np.append(self.y, xy[:,1])

    def image(self, noise=True, noisevar=1., relnoise=0.01):
        """
        Get the image generated by the ensemble of all the point sources
        convolved with the point-spread function.

        ## Keyword Arguments

        * `noise` (bool): Include noise in the image?

        ## Returns

        * `img` (numpy.ndarray): The image where the shape is given by
          `(nx, ny)`.

        """
        # First, initialize the image as a set of zeros.
        img = np.zeros((self.nx, self.ny))

        # Then, loop over the stars and sum up the contributions.
        for k in range(len(self.x)):
            img = self.psf.image(self.x[k], self.y[k], flux=self.flux[k],
                    img=img)

        if noise:
            img += np.sqrt(noisevar + img**2*relnoise) \
                    * np.random.randn(*img.shape)

        return img

if __name__ == "__main__":
    import time
    import matplotlib.pyplot as pl

    psf = PSF([1.2, 0.5], [1.0, 5.0])

    sf = StarField(psf, 200, 200)
    sf.generate_bg_stars(100)
    sf.generate_gaussian_stars(50, 95, 83.5, [[8.**2, 0], [0, 8.**2]])

    s = time.time()
    img = sf.image()
    print "Generating an image w/ %d stars took: %.4f seconds"\
            %(len(sf.x), time.time()-s)

    fig = pl.figure(figsize=(8,8))
    ax = fig.add_subplot(111, aspect="equal")
    ax.pcolor(-img, cmap="gray")
    pl.savefig("example.png")

